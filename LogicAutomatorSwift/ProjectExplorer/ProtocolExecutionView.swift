//
//  ProtocolExecutionView.swift
//  logic
//
//  SwiftUI view for protocol execution interface
//

import SwiftUI
import UniformTypeIdentifiers

struct ProtocolExecutionView: View {
    @StateObject private var protocolExecutor: ProtocolExecutor
    @State private var selectedProtocolFile: URL?
    @State private var protocolDefinition: ProtocolDefinition?
    @State private var executionResult: ProtocolExecutionResult?
    @State private var showingFilePicker = false
    @State private var showingResults = false
    @State private var protocolJSON: String = ""
    @State private var isEditingJSON = false
    
    // Dependencies
    private let regionOperator: LogicRegionOperator
    
    init(regionOperator: LogicRegionOperator) {
        self.regionOperator = regionOperator
        self._protocolExecutor = StateObject(wrappedValue: ProtocolExecutor(
            regionOperator: regionOperator
        ))
    }
    
    var body: some View {
        VStack(spacing: 20) {
            // Header
            VStack(spacing: 8) {
                Text("Protocol Executor")
                    .font(.largeTitle)
                    .fontWeight(.bold)
                
                Text("Execute JSON protocols generated by the learning system")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
            // Protocol Selection Section
            VStack(alignment: .leading, spacing: 12) {
                Text("Protocol Selection")
                    .font(.headline)
                
                HStack {
                    Button("Load Protocol File") {
                        showingFilePicker = true
                    }
                    .buttonStyle(.borderedProminent)
                    
                    if selectedProtocolFile != nil {
                        Button("Clear") {
                            clearProtocol()
                        }
                        .buttonStyle(.bordered)
                    }
                }
                
                if let file = selectedProtocolFile {
                    HStack {
                        Image(systemName: "doc.text")
                            .foregroundColor(.blue)
                        Text(file.lastPathComponent)
                            .font(.caption)
                        Spacer()
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(Color.blue.opacity(0.1))
                    .cornerRadius(8)
                }
            }
            .padding()
            .background(Color.gray.opacity(0.1))
            .cornerRadius(12)
            
            // Protocol Preview Section
            if let protocolDef = protocolDefinition {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("Protocol Preview")
                            .font(.headline)
                        
                        Spacer()
                        
                        Button(isEditingJSON ? "Done" : "Edit JSON") {
                            isEditingJSON.toggle()
                        }
                        .buttonStyle(.bordered)
                    }
                    
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Name: \(protocolDef.protocolName)")
                            .font(.subheadline)
                            .fontWeight(.medium)
                        
                        Text("Description: \(protocolDef.description)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Text("Tags: \(protocolDef.tags.joined(separator: ", "))")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                        Text("Steps: \(protocolDef.steps.count)")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                    
                    if isEditingJSON {
                        TextEditor(text: $protocolJSON)
                            .font(.system(.caption, design: .monospaced))
                            .frame(height: 200)
                            .padding(8)
                            .background(Color.gray.opacity(0.1))
                            .cornerRadius(8)
                        
                        HStack {
                            Button("Apply Changes") {
                                applyJSONChanges()
                            }
                            .buttonStyle(.borderedProminent)
                            
                            Button("Cancel") {
                                isEditingJSON = false
                                loadProtocolJSON()
                            }
                            .buttonStyle(.bordered)
                        }
                    } else {
                        // Steps preview
                        VStack(alignment: .leading, spacing: 4) {
                            ForEach(Array(protocolDef.steps.enumerated()), id: \.offset) { index, step in
                                HStack {
                                    Text("\(index + 1).")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                        .frame(width: 20, alignment: .leading)
                                    
                                    Text(step.intent)
                                        .font(.caption)
                                        .fontWeight(.medium)
                                    
                                    Spacer()
                                }
                                .padding(.vertical, 2)
                            }
                        }
                        .padding(8)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(12)
            }
            
            // Execution Section
            if protocolDefinition != nil {
                VStack(alignment: .leading, spacing: 12) {
                    Text("Execution")
                        .font(.headline)
                    
                    HStack {
                        Button("Execute Protocol") {
                            executeProtocol()
                        }
                        .buttonStyle(.borderedProminent)
                        .disabled(protocolExecutor.isExecuting)
                        
                        if protocolExecutor.isExecuting {
                            ProgressView()
                                .scaleEffect(0.8)
                        }
                    }
                    
                    if protocolExecutor.isExecuting {
                        VStack(alignment: .leading, spacing: 8) {
                            Text(protocolExecutor.currentStep)
                                .font(.subheadline)
                            
                            ProgressView(value: protocolExecutor.progress)
                                .progressViewStyle(LinearProgressViewStyle())
                            
                            Text("\(Int(protocolExecutor.progress * 100))%")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(12)
            }
            
            // Execution Log Section
            if !protocolExecutor.executionLog.isEmpty {
                VStack(alignment: .leading, spacing: 12) {
                    Text("Execution Log")
                        .font(.headline)
                    
                    ScrollView {
                        LazyVStack(alignment: .leading, spacing: 2) {
                            ForEach(protocolExecutor.executionLog, id: \.self) { message in
                                Text(message)
                                    .font(.system(.caption, design: .monospaced))
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                    .frame(maxHeight: 200)
                    .background(Color.black.opacity(0.05))
                    .cornerRadius(8)
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(12)
            }
            
            // Results Section
            if let result = executionResult {
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("Execution Results")
                            .font(.headline)
                        
                        Spacer()
                        
                        Button("Show Details") {
                            showingResults = true
                        }
                        .buttonStyle(.bordered)
                    }
                    
                    HStack {
                        Image(systemName: result.success ? "checkmark.circle.fill" : "xmark.circle.fill")
                            .foregroundColor(result.success ? .green : .red)
                        
                        VStack(alignment: .leading, spacing: 2) {
                            Text(result.success ? "Success" : "Failed")
                                .font(.subheadline)
                                .fontWeight(.medium)
                            
                            Text("\(result.successfulSteps)/\(result.totalSteps) steps completed")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            
                            Text("Time: \(String(format: "%.2f", result.totalExecutionTime))s")
                                .font(.caption)
                                .foregroundColor(.secondary)
                        }
                        
                        Spacer()
                    }
                }
                .padding()
                .background(result.success ? Color.green.opacity(0.1) : Color.red.opacity(0.1))
                .cornerRadius(12)
            }
            
            Spacer()
        }
        .padding()
        .fileImporter(
            isPresented: $showingFilePicker,
            allowedContentTypes: [.json],
            allowsMultipleSelection: false
        ) { result in
            handleFileSelection(result)
        }
        .sheet(isPresented: $showingResults) {
            if let result = executionResult {
                ProtocolResultsView(result: result)
            }
        }
        .onAppear {
            setupLogging()
        }
    }
    
    // MARK: - Private Methods
    
    private func setupLogging() {
        protocolExecutor.logCallback = { message in
            DispatchQueue.main.async {
                protocolExecutor.executionLog.append(message)
            }
        }
    }
    
    private func handleFileSelection(_ result: Result<[URL], Error>) {
        switch result {
        case .success(let urls):
            if let url = urls.first {
                loadProtocolFile(url)
            }
        case .failure(let error):
            print("File selection failed: \(error)")
        }
    }
    
    private func loadProtocolFile(_ url: URL) {
        do {
            let data = try Data(contentsOf: url)
            let parsedProtocol = try protocolExecutor.parseProtocol(from: data)
            
            selectedProtocolFile = url
            protocolDefinition = parsedProtocol
            loadProtocolJSON()
            
        } catch {
            print("Failed to load protocol file: \(error)")
        }
    }
    
    private func loadProtocolJSON() {
        guard let protocolDef = protocolDefinition else { return }
        
        do {
            let encoder = JSONEncoder()
            encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
            let data = try encoder.encode(protocolDef)
            protocolJSON = String(data: data, encoding: .utf8) ?? ""
        } catch {
            print("Failed to encode protocol: \(error)")
        }
    }
    
    private func applyJSONChanges() {
        do {
            let parsedProtocol = try protocolExecutor.parseProtocol(from: protocolJSON)
            protocolDefinition = parsedProtocol
            isEditingJSON = false
        } catch {
            print("Failed to parse modified JSON: \(error)")
        }
    }
    
    private func clearProtocol() {
        selectedProtocolFile = nil
        protocolDefinition = nil
        executionResult = nil
        protocolJSON = ""
        isEditingJSON = false
    }
    
    private func executeProtocol() {
        guard let protocolDef = protocolDefinition else { return }
        
        Task {
            do {
                let result = try await protocolExecutor.executeProtocol(protocolDef)
                await MainActor.run {
                    executionResult = result
                }
            } catch {
                print("Protocol execution failed: \(error)")
            }
        }
    }
}

// MARK: - Results View

struct ProtocolResultsView: View {
    let result: ProtocolExecutionResult
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // Summary
                VStack(alignment: .leading, spacing: 12) {
                    Text("Execution Summary")
                        .font(.headline)
                    
                    HStack {
                        Image(systemName: result.success ? "checkmark.circle.fill" : "xmark.circle.fill")
                            .foregroundColor(result.success ? .green : .red)
                            .font(.title)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text(result.protocolName)
                                .font(.title2)
                                .fontWeight(.bold)
                            
                            Text(result.success ? "Execution Successful" : "Execution Failed")
                                .font(.subheadline)
                                .foregroundColor(result.success ? .green : .red)
                        }
                        
                        Spacer()
                    }
                    
                    HStack {
                        VStack(alignment: .leading) {
                            Text("Total Steps")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text("\(result.totalSteps)")
                                .font(.headline)
                        }
                        
                        VStack(alignment: .leading) {
                            Text("Successful")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text("\(result.successfulSteps)")
                                .font(.headline)
                                .foregroundColor(.green)
                        }
                        
                        VStack(alignment: .leading) {
                            Text("Failed")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text("\(result.failedSteps)")
                                .font(.headline)
                                .foregroundColor(.red)
                        }
                        
                        VStack(alignment: .leading) {
                            Text("Duration")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Text("\(String(format: "%.2f", result.totalExecutionTime))s")
                                .font(.headline)
                        }
                        
                        Spacer()
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(12)
                
                // Step Details
                VStack(alignment: .leading, spacing: 12) {
                    Text("Step Details")
                        .font(.headline)
                    
                    ScrollView {
                        LazyVStack(spacing: 8) {
                            ForEach(Array(result.stepResults.enumerated()), id: \.offset) { index, stepResult in
                                HStack {
                                    Image(systemName: stepResult.success ? "checkmark.circle.fill" : "xmark.circle.fill")
                                        .foregroundColor(stepResult.success ? .green : .red)
                                    
                                    VStack(alignment: .leading, spacing: 2) {
                                        Text("Step \(stepResult.stepIndex + 1): \(stepResult.intent)")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                        
                                        if let message = stepResult.message {
                                            Text(message)
                                                .font(.caption)
                                                .foregroundColor(.secondary)
                                        }
                                        
                                        Text("\(String(format: "%.2f", stepResult.executionTime))s")
                                            .font(.caption)
                                            .foregroundColor(.secondary)
                                    }
                                    
                                    Spacer()
                                }
                                .padding(8)
                                .background(stepResult.success ? Color.green.opacity(0.1) : Color.red.opacity(0.1))
                                .cornerRadius(8)
                            }
                        }
                    }
                }
                .padding()
                .background(Color.gray.opacity(0.1))
                .cornerRadius(12)
                
                Spacer()
            }
            .padding()
            .navigationTitle("Execution Results")
            // .navigationBarTitleDisplayMode(.inline) // Not available on macOS
            .toolbar {
                ToolbarItem(placement: .primaryAction) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}

#Preview {
    ProtocolExecutionView(
        regionOperator: LogicRegionOperator()
    )
}
