//
//  ProtocolExecutor.swift
//  logic
//
//  Protocol execution engine for Logic Pro automation
//  Parses and executes JSON protocol files generated by the learning system
//

import Foundation
import SwiftUI
import ApplicationServices

// MARK: - Data Models

/// Protocol definition structure matching the JSON format
struct ProtocolDefinition: Codable {
    let protocolName: String
    let description: String
    let tags: [String]
    let steps: [ProtocolStep]
    
    enum CodingKeys: String, CodingKey {
        case protocolName = "protocol"
        case description, tags, steps
    }
}

/// Individual protocol step with intent and parameters
struct ProtocolStep: Codable {
    let intent: String
    let parameters: [String: Any]
    
    // Custom coding keys to handle Any type
    enum CodingKeys: String, CodingKey {
        case intent, parameters
    }
    
    init(intent: String, parameters: [String: Any]) {
        self.intent = intent
        self.parameters = parameters
    }
    
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        intent = try container.decode(String.self, forKey: .intent)
        
        // Handle parameters as [String: Any]
        let parametersContainer = try container.nestedContainer(keyedBy: DynamicCodingKey.self, forKey: .parameters)
        var parameters: [String: Any] = [:]
        
        for key in parametersContainer.allKeys {
            if let stringValue = try? parametersContainer.decode(String.self, forKey: key) {
                parameters[key.stringValue] = stringValue
            } else if let intValue = try? parametersContainer.decode(Int.self, forKey: key) {
                parameters[key.stringValue] = intValue
            } else if let doubleValue = try? parametersContainer.decode(Double.self, forKey: key) {
                parameters[key.stringValue] = doubleValue
            } else if let boolValue = try? parametersContainer.decode(Bool.self, forKey: key) {
                parameters[key.stringValue] = boolValue
            } else if let arrayValue = try? parametersContainer.decode([String].self, forKey: key) {
                parameters[key.stringValue] = arrayValue
            }
        }
        
        self.parameters = parameters
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(intent, forKey: .intent)
        
        var parametersContainer = container.nestedContainer(keyedBy: DynamicCodingKey.self, forKey: .parameters)
        for (key, value) in parameters {
            let codingKey = DynamicCodingKey(stringValue: key)!
            if let stringValue = value as? String {
                try parametersContainer.encode(stringValue, forKey: codingKey)
            } else if let intValue = value as? Int {
                try parametersContainer.encode(intValue, forKey: codingKey)
            } else if let doubleValue = value as? Double {
                try parametersContainer.encode(doubleValue, forKey: codingKey)
            } else if let boolValue = value as? Bool {
                try parametersContainer.encode(boolValue, forKey: codingKey)
            } else if let arrayValue = value as? [String] {
                try parametersContainer.encode(arrayValue, forKey: codingKey)
            }
        }
    }
}

/// Dynamic coding key for handling arbitrary parameter keys
struct DynamicCodingKey: CodingKey {
    var stringValue: String
    var intValue: Int?
    
    init?(stringValue: String) {
        self.stringValue = stringValue
    }
    
    init?(intValue: Int) {
        self.intValue = intValue
        self.stringValue = "\(intValue)"
    }
}

/// Execution result for individual steps
struct StepExecutionResult {
    let stepIndex: Int
    let intent: String
    let success: Bool
    let error: Error?
    let executionTime: TimeInterval
    let message: String?
}

/// Overall protocol execution result
struct ProtocolExecutionResult {
    let protocolName: String
    let totalSteps: Int
    let successfulSteps: Int
    let failedSteps: Int
    let totalExecutionTime: TimeInterval
    let stepResults: [StepExecutionResult]
    let success: Bool
    let error: Error?
}

// MARK: - Protocol Executor

/// Main protocol execution engine
class ProtocolExecutor: ObservableObject {
    @Published var isExecuting = false
    @Published var currentStep: String = ""
    @Published var progress: Double = 0.0
    @Published var lastError: String?
    @Published var executionLog: [String] = []
    
    // Dependencies
    private let regionOperator: LogicRegionOperator
    
    // Intent handlers registry
    private var intentHandlers: [String: IntentHandler] = [:]
    
    // Log callback
    var logCallback: ((String) -> Void)?
    
    init(regionOperator: LogicRegionOperator) {
        self.regionOperator = regionOperator
        
        setupIntentHandlers()
    }
    
    // MARK: - Public Methods
    
    /// Parse protocol from JSON data
    func parseProtocol(from jsonData: Data) throws -> ProtocolDefinition {
        let decoder = JSONDecoder()
        return try decoder.decode(ProtocolDefinition.self, from: jsonData)
    }
    
    /// Parse protocol from JSON string
    func parseProtocol(from jsonString: String) throws -> ProtocolDefinition {
        guard let data = jsonString.data(using: .utf8) else {
            throw ProtocolError.invalidJSON("Failed to convert string to data")
        }
        return try parseProtocol(from: data)
    }
    
    /// Execute a complete protocol
    func executeProtocol(_ protocolDef: ProtocolDefinition) async -> ProtocolExecutionResult {
        await MainActor.run {
            isExecuting = true
            currentStep = "Starting protocol..."
            progress = 0.0
            lastError = nil
            executionLog.removeAll()
        }
        
        let startTime = Date()
        var stepResults: [StepExecutionResult] = []
        var successfulSteps = 0
        var failedSteps = 0
        
        log("ðŸŽ¬ Starting protocol execution: \(protocolDef.protocolName)")
        log("ðŸ“‹ Description: \(protocolDef.description)")
        log("ðŸ·ï¸ Tags: \(protocolDef.tags.joined(separator: ", "))")
        log("ðŸ“Š Total steps: \(protocolDef.steps.count)")
        
        do {
            // Ensure Logic Pro is ready
            try await ensureLogicProReady()
            
            // Execute each step
            for (index, step) in protocolDef.steps.enumerated() {
                let stepStartTime = Date()
                var stepError: Error? = nil
                var stepMessage: String? = nil
                
                await MainActor.run {
                    currentStep = "Step \(index + 1)/\(protocolDef.steps.count): \(step.intent)"
                    progress = Double(index) / Double(protocolDef.steps.count)
                }
                
                log("âž¡ï¸ Executing step \(index + 1): \(step.intent) with parameters: \(step.parameters)")
                
                do {
                    try await executeStep(step)
                    successfulSteps += 1
                    stepMessage = "Step \(index + 1) (\(step.intent)) successful"
                    log("âœ… Step \(index + 1) successful")
                } catch {
                    failedSteps += 1
                    stepError = error
                    stepMessage = "Step \(index + 1) (\(step.intent)) failed: \(error.localizedDescription)"
                    log("âŒ Step \(index + 1) failed: \(error.localizedDescription)")
                    
                    if shouldStopOnError(for: step, error: error) {
                        log("ðŸ›‘ Critical error, stopping protocol execution.")
                        break // Stop execution on critical errors
                    }
                }
                
                let stepExecutionTime = Date().timeIntervalSince(stepStartTime)
                stepResults.append(StepExecutionResult(
                    stepIndex: index,
                    intent: step.intent,
                    success: stepError == nil,
                    error: stepError,
                    executionTime: stepExecutionTime,
                    message: stepMessage
                ))
            }
        } catch {
            failedSteps = protocolDef.steps.count // Mark all steps as failed if initial setup fails
            lastError = error.localizedDescription
            log("âŒ Protocol execution failed during setup: \(error.localizedDescription)")
        }
        
        let totalExecutionTime = Date().timeIntervalSince(startTime)
        let success = failedSteps == 0
        
        await MainActor.run {
            progress = 1.0
            currentStep = success ? "Protocol completed successfully!" : "Protocol completed with errors"
            isExecuting = false
        }
        
        let result = ProtocolExecutionResult(
            protocolName: protocolDef.protocolName,
            totalSteps: protocolDef.steps.count,
            successfulSteps: successfulSteps,
            failedSteps: failedSteps,
            totalExecutionTime: totalExecutionTime,
            stepResults: stepResults,
            success: success,
            error: success ? nil : ProtocolError.executionFailed("\(failedSteps) steps failed")
        )
        
        log("ðŸ Protocol execution completed")
        log("ðŸ“Š Results: \(successfulSteps)/\(protocolDef.steps.count) steps successful")
        log("â±ï¸ Total time: \(String(format: "%.2f", totalExecutionTime))s")
        
        return result
    }
    
    /// Execute a single step
    func executeStep(_ step: ProtocolStep) async throws {
        guard let handler = intentHandlers[step.intent] else {
            throw ProtocolError.unknownIntent(step.intent)
        }
        
        try await handler.execute(parameters: step.parameters, context: ExecutionContext(
            regionOperator: regionOperator,
            logCallback: logCallback
        ))
    }
    
    // MARK: - Private Methods
    
    /// Setup intent handlers
    private func setupIntentHandlers() {
        // Track operations
        intentHandlers["select_track"] = SelectTrackHandler()
        intentHandlers["create_track"] = CreateTrackHandler()
        
        // Region operations
        intentHandlers["create_region"] = CreateRegionHandler()
        intentHandlers["quantize_region"] = QuantizeRegionHandler()
        intentHandlers["move_region"] = MoveRegionHandler()
        intentHandlers["resize_region"] = ResizeRegionHandler()
        
        // Import operations
        intentHandlers["import_chords"] = ImportChordsHandler()
        intentHandlers["import_midi"] = ImportMidiHandler()
        
        // Playback operations
        intentHandlers["play"] = PlayHandler()
        intentHandlers["stop"] = StopHandler()
        intentHandlers["record"] = RecordHandler()
        
        // Project operations
        intentHandlers["set_tempo"] = SetTempoHandler()
        intentHandlers["set_key"] = SetKeyHandler()
        intentHandlers["save_project"] = SaveProjectHandler()
        
        log("ðŸ”§ Registered \(intentHandlers.count) intent handlers")
    }
    
    /// Ensure Logic Pro is ready for execution
    private func ensureLogicProReady() async throws {
        log("ðŸ” Checking Logic Pro status...")
        
        // Check permissions
        let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue(): true]
        guard AXIsProcessTrustedWithOptions(options as CFDictionary) else {
            throw ProtocolError.accessibilityNotEnabled
        }
        
        // Check if Logic Pro is running
        let runningApps = NSWorkspace.shared.runningApplications
        let logicApp = runningApps.first { $0.bundleIdentifier == "com.apple.logic10" }
        
        if logicApp == nil {
            throw ProtocolError.logicProNotRunning
        }
        
        log("âœ… Logic Pro is ready for protocol execution")
    }
    
    /// Determine if execution should stop on error
    private func shouldStopOnError(for step: ProtocolStep, error: Error) -> Bool {
        // Critical errors that should stop execution
        if error is ProtocolError {
            switch error as! ProtocolError {
            case .accessibilityNotEnabled, .logicProNotRunning:
                return true
            default:
                return false
            }
        }
        
        // For now, continue execution on most errors
        // This can be made configurable later
        return false
    }
    
    /// Log message with callback support
    private func log(_ message: String) {
        let timestamp = DateFormatter.localizedString(from: Date(), dateStyle: .none, timeStyle: .medium)
        let logMessage = "[\(timestamp)] \(message)"
        
        print(logMessage)
        logCallback?(logMessage)
        
        DispatchQueue.main.async {
            self.executionLog.append(logMessage)
            // Keep only last 100 log messages
            if self.executionLog.count > 100 {
                self.executionLog.removeFirst(20)
            }
        }
    }
}

// MARK: - Execution Context

/// Context passed to intent handlers
struct ExecutionContext {
    let regionOperator: LogicRegionOperator
    let logCallback: ((String) -> Void)?
    
    func log(_ message: String) {
        let timestamp = DateFormatter.localizedString(from: Date(), dateStyle: .none, timeStyle: .medium)
        let logMessage = "[\(timestamp)] \(message)"
        
        print(logMessage)
        logCallback?(logMessage)
    }
}

// MARK: - Intent Handler Protocol

/// Protocol for intent handlers
protocol IntentHandler {
    func execute(parameters: [String: Any], context: ExecutionContext) async throws
}

// MARK: - Protocol Errors

enum ProtocolError: LocalizedError {
    case invalidJSON(String)
    case unknownIntent(String)
    case executionInProgress
    case executionFailed(String)
    case accessibilityNotEnabled
    case logicProNotRunning
    case invalidParameters(String)
    case stepExecutionFailed(String)
    
    var errorDescription: String? {
        switch self {
        case .invalidJSON(let message):
            return "Invalid JSON: \(message)"
        case .unknownIntent(let intent):
            return "Unknown intent: \(intent)"
        case .executionInProgress:
            return "Protocol execution is already in progress"
        case .executionFailed(let message):
            return "Execution failed: \(message)"
        case .accessibilityNotEnabled:
            return "Accessibility permissions not enabled"
        case .logicProNotRunning:
            return "Logic Pro is not running"
        case .invalidParameters(let message):
            return "Invalid parameters: \(message)"
        case .stepExecutionFailed(let message):
            return "Step execution failed: \(message)"
        }
    }
}
